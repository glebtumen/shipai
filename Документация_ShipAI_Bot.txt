ДОКУМЕНТАЦИЯ TELEGRAM БОТА SHIPAI
=====================================

СОДЕРЖАНИЕ:
1. Общий обзор проекта
2. Архитектура системы
3. Структура файлов и их назначение
4. Детальный разбор кода
5. База данных
6. Машина состояний (FSM)
7. Планировщик задач
8. Обработка команд
9. Интеграция с OpenAI
10. Работа с изображениями
11. Конфигурация и настройки

=====================================

1. ОБЩИЙ ОБЗОР ПРОЕКТА
======================

ShipAI - это Telegram бот для автоматизации публикаций в канале на тематику судоходства и судостроения.

ОСНОВНЫЕ ФУНКЦИИ:
- Принимает от пользователя оригинальный текст статьи
- Обрабатывает текст через OpenAI API для улучшения стиля и форматирования
- Позволяет добавлять изображения к публикациям
- Автоматически планирует публикации на оптимальное время (5 слотов в день)
- Управляет очередью публикаций (просмотр, удаление, немедленная публикация)
- Сохраняет все данные в локальной SQLite базе данных

ЦЕЛЕВАЯ АУДИТОРИЯ: Люди, интересующиеся судоходством и судостроением

=====================================

2. АРХИТЕКТУРА СИСТЕМЫ
======================

Система состоит из нескольких взаимосвязанных компонентов:

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Telegram      │    │     OpenAI      │    │    SQLite       │
│     User        │◄──►│      API        │    │   Database      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                        BOT.PY                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │   Router    │  │     FSM     │  │      Scheduler          │  │
│  │ (Commands)  │  │ (States)    │  │   (Auto-posting)        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    CONFIG.PY    │    │   DATABASE.PY   │    │   Telegram      │
│  (Settings)     │    │   (DB Logic)    │    │    Channel      │
└─────────────────┘    └─────────────────┘    └─────────────────┘

ПОТОК ДАННЫХ:
1. Пользователь отправляет команду боту
2. Бот обрабатывает команду через роутеры
3. При добавлении статьи - текст отправляется в OpenAI для обработки
4. Обработанный текст и метаданные сохраняются в базу данных
5. Планировщик автоматически назначает время публикации
6. В назначенное время статья публикуется в канал

=====================================

3. СТРУКТУРА ФАЙЛОВ И ИХ НАЗНАЧЕНИЕ
===================================

bot.py - ОСНОВНОЙ ФАЙЛ БОТА (400+ строк)
├── Импорты библиотек
├── Инициализация бота и диспетчера
├── Определение состояний FSM
├── Роутеры для обработки команд
├── Функции планировщика
└── Главная функция запуска

config.py - КОНФИГУРАЦИЯ (50 строк)
├── Загрузка переменных окружения
├── Настройки API ключей
├── Промпт для обработки текста OpenAI
└── Настройки базы данных

database.py - РАБОТА С БАЗОЙ ДАННЫХ (80 строк)
├── Функции подключения к БД
├── Создание таблиц
├── CRUD операции (Create, Read, Update, Delete)
└── Функции для работы со статьями

requirements.txt - ЗАВИСИМОСТИ
├── aiogram (Telegram Bot API)
├── openai (OpenAI API)
├── apscheduler (Планировщик задач)
└── python-dotenv (Переменные окружения)

.env.example - ПРИМЕР НАСТРОЕК
├── BOT_TOKEN (токен Telegram бота)
├── API_KEY (ключ OpenAI)
├── CHANNEL_NAME (имя канала для публикаций)
├── MODEL (модель OpenAI)
└── DATABASE_FILE (файл базы данных)

=====================================

4. ДЕТАЛЬНЫЙ РАЗБОР КОДА
========================

4.1 ИМПОРТЫ И ИНИЦИАЛИЗАЦИЯ (bot.py, строки 1-40)
--------------------------------------------------

import asyncio          # Асинхронное программирование
import logging          # Логирование ошибок и событий
from datetime import datetime, timedelta  # Работа с датами
from aiogram import Bot, Dispatcher, Router  # Telegram Bot API
from openai import OpenAI  # OpenAI API для обработки текста

ЗАЧЕМ НУЖНЫ:
- asyncio: Python бот работает асинхронно, может обрабатывать много запросов одновременно
- logging: Записывает ошибки и важные события в лог для отладки
- datetime: Нужен для планирования публикаций по времени
- aiogram: Основная библиотека для создания Telegram ботов
- openai: Для улучшения текста статей через искусственный интеллект

ИНИЦИАЛИЗАЦИЯ:
bot = Bot(token=BOT_TOKEN)  # Создаем объект бота с токеном
dp = Dispatcher()           # Диспетчер для обработки сообщений
storage = MemoryStorage()   # Хранилище состояний в памяти


Декоратор @admin_required

def admin_required(func):
    """Decorator to check if user is admin before executing command"""
    async def wrapper(message: Message, *args, **kwargs):
        user_id = message.from_user.id
        if user_id not in ADMIN_USER_IDS:
            await message.reply("❌ Доступ запрещен. Эта команда доступна только администраторам.")
            logging.warning(f"Unauthorized access attempt by user {user_id} (@{message.from_user.username})")
            return
        return await func(message, *args, **kwargs)
    return wrapper

Проверяет, является ли пользователь администратором и вызывает функцию если он является.

4.2 МАШИНА СОСТОЯНИЙ FSM (строки 41-45)
----------------------------------------

class ArticleSubmission(StatesGroup):
    waiting_for_text = State()   # Ожидание текста статьи
    waiting_for_image = State()  # Ожидание изображения

ЧТО ЭТО ЗНАЧИТ:
FSM (Finite State Machine) - это способ отслеживать, на каком этапе находится разговор с пользователем.

ПРИМЕР РАБОТЫ:
1. Пользователь пишет /new_article
2. Бот переходит в состояние "waiting_for_text"
3. Пользователь отправляет текст
4. Бот обрабатывает текст и переходит в "waiting_for_image"
5. Пользователь отправляет фото или пропускает
6. Бот сохраняет статью и очищает состояние

4.3 РОУТЕРЫ - ОБРАБОТЧИКИ КОМАНД
---------------------------------

article_router = Router()  # Роутер для работы со статьями
queue_router = Router()    # Роутер для управления очередью

РОУТЕРЫ - это группировка обработчиков команд по функциональности.
Это помогает организовать код и делает его более читаемым.

=====================================

5. БАЗА ДАННЫХ (database.py)
=============================

5.1 СТРУКТУРА ТАБЛИЦЫ ARTICLES
------------------------------

CREATE TABLE articles (
    id INTEGER PRIMARY KEY,      # Уникальный номер статьи
    text TEXT,                   # Оригинальный текст от пользователя
    processed_text TEXT,         # Обработанный OpenAI текст
    image_path TEXT,             # Путь к изображению (если есть)
    status TEXT,                 # Статус: 'queued' или 'deleted'
    created_at TIMESTAMP,        # Когда создана статья
    scheduled_at TIMESTAMP       # Когда запланирована публикация
)

5.2 ОСНОВНЫЕ ФУНКЦИИ БАЗЫ ДАННЫХ
---------------------------------

create_connection() - ПОДКЛЮЧЕНИЕ К БД
def create_connection():
    conn = sqlite3.connect(DATABASE_FILE)  # Подключаемся к файлу БД
    return conn

add_article() - ДОБАВЛЕНИЕ СТАТЬИ
def add_article(text, processed_text, image_path=None):
    conn = create_connection()              # Подключаемся
    cursor = conn.cursor()                  # Создаем курсор для запросов
    cursor.execute("""INSERT INTO articles...""")  # Выполняем запрос
    conn.commit()                           # Сохраняем изменения
    conn.close()                            # Закрываем соединение

get_queued_articles() - ПОЛУЧЕНИЕ ОЧЕРЕДИ
Возвращает все статьи со статусом 'queued' для показа пользователю

delete_article() - "УДАЛЕНИЕ" СТАТЬИ
На самом деле не удаляет, а меняет статус на 'deleted' для сохранения истории

update_time_scheduled() - ОБНОВЛЕНИЕ ВРЕМЕНИ ПУБЛИКАЦИИ
Устанавливает время, когда статья должна быть опубликована

=====================================

6. МАШИНА СОСТОЯНИЙ - ПОДРОБНО
===============================

6.1 КАК РАБОТАЮТ СОСТОЯНИЯ
---------------------------

Состояния позволяют боту "помнить" контекст разговора с каждым пользователем.

ПРИМЕР БЕЗ СОСТОЯНИЙ (плохо):
Пользователь: /new_article
Бот: Отправьте текст
Пользователь: Привет как дела?
Бот: ??? (не понимает, что это текст статьи)

ПРИМЕР С СОСТОЯНИЯМИ (хорошо):
Пользователь: /new_article
Бот: Отправьте текст (устанавливает состояние waiting_for_text)
Пользователь: Привет как дела?
Бот: Понимает, что это текст статьи, обрабатывает его

6.2 ОБРАБОТЧИКИ СОСТОЯНИЙ
--------------------------

@article_router.message(ArticleSubmission.waiting_for_text)
async def process_article_text(message: Message, state: FSMContext):

ДЕКОРАТОР @article_router.message() говорит:
"Эта функция должна выполняться, когда пользователь отправляет сообщение 
И находится в состоянии waiting_for_text"

ПАРАМЕТРЫ ФУНКЦИИ:
- message: объект сообщения от пользователя
- state: объект для работы с состоянием (сохранение данных, переход между состояниями)

6.3 СОХРАНЕНИЕ ДАННЫХ МЕЖДУ СОСТОЯНИЯМИ
----------------------------------------

await state.update_data(original_text=text, processed_text=processed_text)

Это сохраняет данные в памяти для конкретного пользователя.
Позже можно получить эти данные:

data = await state.get_data()
original_text = data["original_text"]

=====================================

7. ПЛАНИРОВЩИК ЗАДАЧ (SCHEDULER)
================================

7.1 ИНИЦИАЛИЗАЦИЯ ПЛАНИРОВЩИКА
-------------------------------

from apscheduler.schedulers.asyncio import AsyncIOScheduler
scheduler = AsyncIOScheduler()

AsyncIOScheduler - это планировщик, который может выполнять задачи по расписанию
в асинхронном режиме (не блокируя основную работу бота).

7.2 ЛОГИКА ПЛАНИРОВАНИЯ ПУБЛИКАЦИЙ
-----------------------------------

ВРЕМЕННЫЕ СЛОТЫ (5 раз в день):
- 9:00 - Утренняя активность
- 11:12 - Середина утра  
- 13:24 - Обеденный перерыв
- 15:36 - После обеда
- 17:48 - Вечернее время

ИНТЕРВАЛ: 132 минуты между публикациями (2 часа 12 минут)

АЛГОРИТМ ПЛАНИРОВАНИЯ:
1. Получить текущее время
2. Определить доступные слоты на сегодня
3. Если время после 20:00 - планировать на завтра
4. Назначить статьи на свободные слоты по порядку
5. Если слоты закончились - планировать на следующие дни

7.3 ФУНКЦИЯ schedule_posts()
----------------------------

async def schedule_posts():
    articles = get_queued_articles()  # Получаем неопубликованные статьи
    
    # Вычисляем доступные временные слоты
    now = datetime.now()
    today_9am = now.replace(hour=9, minute=0, second=0, microsecond=0)
    
    # Для каждой статьи без расписания
    for article in articles:
        if not scheduled_at:  # Если время не назначено
            # Назначаем следующий доступный слот
            scheduler.add_job(
                post_article_to_channel,  # Функция для выполнения
                "date",                   # Тип: выполнить в определенную дату
                run_date=post_time,       # Когда выполнить
                args=[article_id, text, image_path],  # Аргументы функции
                id=f"article_{article_id}"  # Уникальный ID задачи
            )

7.4 АВТОМАТИЧЕСКИЙ ЗАПУСК ПЛАНИРОВЩИКА
---------------------------------------

scheduler.add_job(schedule_posts, "interval", minutes=1)

Эта строка говорит планировщику:
"Выполняй функцию schedule_posts каждую минуту"

Зачем каждую минуту?
- Проверять новые статьи в очереди
- Назначать им время публикации
- Обновлять расписание при изменениях

=====================================

8. ОБРАБОТКА КОМАНД - ПОШАГОВО
===============================

8.1 КОМАНДА /start
------------------

@article_router.message(Command("start"))
async def start_command(message: Message):
    help_text = """Добро пожаловать в ShipAI!..."""
    await message.answer(help_text, parse_mode="HTML")

ЧТО ПРОИСХОДИТ:
1. Пользователь отправляет /start
2. Декоратор @article_router.message(Command("start")) перехватывает команду
3. Функция start_command выполняется
4. Отправляется приветственное сообщение с инструкциями

8.2 КОМАНДА /new_article - НАЧАЛО ДОБАВЛЕНИЯ СТАТЬИ
----------------------------------------------------

@article_router.message(Command("new_article"))
async def new_article_command(message: Message, state: FSMContext):
    await message.reply("Отправьте текст оригинальной публикации.")
    await state.set_state(ArticleSubmission.waiting_for_text)

ПОШАГОВО:
1. Пользователь: /new_article
2. Бот отвечает: "Отправьте текст..."
3. Устанавливается состояние waiting_for_text
4. Теперь бот ждет следующее сообщение как текст статьи

8.3 ОБРАБОТКА ТЕКСТА СТАТЬИ
----------------------------

@article_router.message(ArticleSubmission.waiting_for_text)
async def process_article_text(message: Message, state: FSMContext):
    original_text = message.text  # Получаем текст от пользователя
    
    # Отправляем в OpenAI для обработки
    client = OpenAI(api_key=API_KEY)
    completion = client.chat.completions.create(
        model=MODEL,
        messages=[
            {"role": "user", "content": TEXT_PROCESSING_PROMPT},
            {"role": "user", "content": original_text},
        ],
        max_tokens=350,
    )
    
    processed_text = completion.choices[0].message.content
    
    # Сохраняем данные в состоянии
    await state.update_data(
        original_text=original_text, 
        processed_text=processed_text
    )
    
    # Переходим к следующему состоянию
    await state.set_state(ArticleSubmission.waiting_for_image)

ВАЖНЫЕ МОМЕНТЫ:
- Оригинальный текст сохраняется для истории
- OpenAI обрабатывает текст согласно промпту из config.py
- Обработанный текст будет опубликован в канале
- Данные сохраняются в состоянии для следующего шага

8.4 ОБРАБОТКА ИЗОБРАЖЕНИЯ
--------------------------

@article_router.message(ArticleSubmission.waiting_for_image, F.content_type == "photo")
async def process_article_image(message: Message, state: FSMContext):
    photo = message.photo[-1]  # Берем фото лучшего качества
    
    # Создаем папку для изображений
    os.makedirs("images", exist_ok=True)
    
    # Сохраняем изображение
    image_path = f"images/{photo.file_unique_id}.jpg"
    await bot.download(photo, destination=image_path)
    
    # Получаем сохраненные данные
    data = await state.get_data()
    
    # Добавляем статью в базу данных
    add_article(data["original_text"], data["processed_text"], image_path=image_path)
    
    await state.clear()  # Очищаем состояние

ФИЛЬТР F.content_type == "photo":
Этот фильтр гарантирует, что функция выполнится только если пользователь 
отправил именно фотографию, а не текст или другой тип контента.

8.5 КОМАНДА /queue - ПРОСМОТР ОЧЕРЕДИ
--------------------------------------

@queue_router.message(Command("queue"))
async def view_queue(message: Message):
    articles = get_queued_articles()  # Получаем статьи из БД
    
    if not articles:
        await message.reply("Очередь публикаций пуста.")
    else:
        queue_message = "Очередь публикаций:\n\n"
        for article in articles:
            # Формируем сообщение для каждой статьи
            queue_message += f"ID: {article[0]}\n{article[2][:60]}...\n"
            queue_message += f"Запланировано на: {article[6]}\n\n"
        
        await message.reply(queue_message, parse_mode="HTML")

СТРУКТУРА ДАННЫХ article:
article[0] = id (номер статьи)
article[1] = text (оригинальный текст)
article[2] = processed_text (обработанный текст)
article[3] = image_path (путь к изображению)
article[4] = status (статус)
article[5] = created_at (время создания)
article[6] = scheduled_at (время публикации)

=====================================

9. ИНТЕГРАЦИЯ С OPENAI
======================

9.1 НАСТРОЙКА КЛИЕНТА
----------------------

client = OpenAI(api_key=API_KEY)

API_KEY берется из переменных окружения (.env файл)
Это секретный ключ для доступа к OpenAI API

9.2 ПРОМПТ ДЛЯ ОБРАБОТКИ ТЕКСТА
--------------------------------

TEXT_PROCESSING_PROMPT содержит детальные инструкции для ИИ:

"""
Ты - редактор и копирайтер. Твоя задача преобразовать текст в готовую публикацию для телеграмм.   
Тон ближе к официальному. Целевая аудитория - люди, интересующиеся тематикой судоходства и судостроения. 
Добавляй эмодзи, информативное представление списками, хэштег в конце каждой публикации - #залоговыйлоцман. 
Пиши только основное, кратко 

ВАЖНО: Используй только HTML форматирование...
"""

ЗАЧЕМ НУЖЕН ПРОМПТ:
- Задает стиль и тон публикаций
- Определяет целевую аудиторию
- Устанавливает правила форматирования
- Обеспечивает единообразие всех публикаций

9.3 ОТПРАВКА ЗАПРОСА В OPENAI
-----------------------------

completion = client.chat.completions.create(
    model=MODEL,                    # Модель ИИ (gpt-4.1-nano)
    messages=[
        {"role": "user", "content": TEXT_PROCESSING_PROMPT},  # Инструкции
        {"role": "user", "content": original_text},           # Исходный текст
    ],
    max_tokens=350,                 # Максимум токенов в ответе
)

processed_text = completion.choices[0].message.content

СТРУКТУРА ЗАПРОСА:
- model: какую модель ИИ использовать
- messages: массив сообщений (промпт + исходный текст)
- max_tokens: ограничение длины ответа (экономия средств)

ПОЛУЧЕНИЕ ОТВЕТА:
completion.choices[0].message.content содержит обработанный текст

=====================================

10. РАБОТА С ИЗОБРАЖЕНИЯМИ
==========================

10.1 ПОЛУЧЕНИЕ ИЗОБРАЖЕНИЯ ОТ ПОЛЬЗОВАТЕЛЯ
-------------------------------------------

photo = message.photo[-1]  # Берем последнее фото (лучшее качество)

Telegram отправляет несколько версий фото разного размера.
message.photo[-1] берет последнее (самое большое и качественное).

10.2 СОЗДАНИЕ ПАПКИ ДЛЯ ИЗОБРАЖЕНИЙ
------------------------------------

os.makedirs("images", exist_ok=True)

exist_ok=True означает: "Создай папку, но не выдавай ошибку, если она уже существует"

10.3 СКАЧИВАНИЕ И СОХРАНЕНИЕ
-----------------------------

image_path = f"images/{photo.file_unique_id}.jpg"
await bot.download(photo, destination=image_path)

file_unique_id - уникальный идентификатор файла от Telegram
Используется как имя файла для избежания конфликтов

10.4 ОТПРАВКА ИЗОБРАЖЕНИЯ В КАНАЛ
----------------------------------

if image_path and os.path.exists(image_path):
    photo = FSInputFile(image_path)  # Создаем объект файла
    await bot.send_photo(
        chat_id=CHANNEL_NAME,        # Куда отправить
        photo=photo,                 # Файл изображения
        caption=text,                # Подпись к фото
    )
else:
    await bot.send_message(chat_id=CHANNEL_NAME, text=text)

ЛОГИКА:
- Если есть изображение - отправляем фото с текстом как подпись
- Если нет изображения - отправляем только текст

=====================================

11. КОНФИГУРАЦИЯ И НАСТРОЙКИ
============================

11.1 ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ (.env)
--------------------------------

BOT_TOKEN=your_telegram_bot_token      # Токен бота от @BotFather
API_KEY=your_openai_api_key           # Ключ OpenAI API
CHANNEL_NAME=@your_channel_username   # Имя канала для публикаций
MODEL=deepseek/deepseek-chat-v3-0324:free       # Модель 
DATABASE_FILE=articles.db             # Файл базы данных

ЗАЧЕМ .env ФАЙЛ:
- Безопасность: секретные ключи не попадают в код
- Гибкость: можно менять настройки без изменения кода
- Разные окружения: разные настройки для разработки и продакшена

11.2 ЗАГРУЗКА ПЕРЕМЕННЫХ (config.py)
------------------------------------

from dotenv import load_dotenv
load_dotenv()  # Загружает переменные из .env файла

BOT_TOKEN = os.getenv("BOT_TOKEN")     # Получает значение переменной
API_KEY = os.getenv("API_KEY")

os.getenv() безопасно получает переменную окружения.
Если переменная не найдена, возвращает None.

11.3 НАСТРОЙКИ ПО УМОЛЧАНИЮ
----------------------------

CHANNEL_NAME = os.getenv("CHANNEL_NAME", "@glebnft")
MODEL = os.getenv("MODEL", "gpt-4.1-nano")

Второй параметр - значение по умолчанию, если переменная не задана.

=====================================

12. ПОЛНЫЙ ЖИЗНЕННЫЙ ЦИКЛ СТАТЬИ
=================================

12.1 СОЗДАНИЕ СТАТЬИ
--------------------
1. Пользователь: /new_article
2. Бот: "Отправьте текст" (состояние: waiting_for_text)
3. Пользователь: отправляет текст
4. Бот: обрабатывает через OpenAI
5. Бот: "Отправьте изображение" (состояние: waiting_for_image)
6. Пользователь: отправляет фото или пропускает
7. Бот: сохраняет в БД со статусом 'queued'

12.2 ПЛАНИРОВАНИЕ
-----------------
1. Планировщик каждую минуту проверяет новые статьи
2. Находит статьи без назначенного времени (scheduled_at = NULL)
3. Вычисляет следующий доступный временной слот
4. Обновляет scheduled_at в базе данных
5. Добавляет задачу в планировщик

12.3 ПУБЛИКАЦИЯ
---------------
1. Наступает назначенное время
2. Планировщик вызывает post_article_to_channel()
3. Функция отправляет статью в Telegram канал
4. Статья помечается как опубликованная (статус 'deleted')
5. Задача удаляется из планировщика

12.4 УПРАВЛЕНИЕ ОЧЕРЕДЬЮ
------------------------
- /queue - показать все запланированные статьи
- /delete ID - удалить статью из очереди
- /post_now ID - опубликовать немедленно

=====================================

13. ОБРАБОТКА ОШИБОК И ЛОГИРОВАНИЕ
===================================

13.1 НАСТРОЙКА ЛОГИРОВАНИЯ
---------------------------

logging.basicConfig(level=logging.INFO)

Устанавливает уровень логирования INFO.
Будут записываться сообщения уровня INFO, WARNING, ERROR, CRITICAL.

13.2 ПРИМЕРЫ ЛОГИРОВАНИЯ В КОДЕ
--------------------------------

logging.info(f"Scheduled article {article_id} for posting at {post_time}")
logging.error(f"Error processing text: {e}")

INFO - информационные сообщения (успешные операции)
ERROR - ошибки, которые не останавливают работу программы

13.3 ОБРАБОТКА ИСКЛЮЧЕНИЙ
--------------------------

try:
    # Опасная операция (например, запрос к OpenAI)
    completion = client.chat.completions.create(...)
except Exception as e:
    logging.error(f"Error processing text: {e}")
    await message.reply("Ошибка при обработке текста. Попробуйте еще раз.")
    await state.clear()  # Очищаем состояние при ошибке

ВАЖНО:
- Всегда обрабатывать исключения при внешних запросах
- Информировать пользователя об ошибке понятным языком
- Очищать состояние при критических ошибках
- Логировать детали ошибки для отладки

=====================================

14. АСИНХРОННОЕ ПРОГРАММИРОВАНИЕ
=================================

14.1 ЗАЧЕМ НУЖНА АСИНХРОННОСТЬ
-------------------------------

Telegram бот должен обрабатывать много пользователей одновременно.
Без асинхронности бот мог бы "зависнуть" на одном пользователе.

СИНХРОННЫЙ КОД (плохо):
def process_text(text):
    response = openai_api.call(text)  # Ждем 2 секунды
    return response

Если 10 пользователей отправят текст одновременно, 
последний будет ждать 20 секунд!

АСИНХРОННЫЙ КОД (хорошо):
async def process_text(text):
    response = await openai_api.call(text)  # Не блокирует другие операции
    return response

Все 10 пользователей получат ответ примерно через 2 секунды.

14.2 КЛЮЧЕВЫЕ СЛОВА async/await
-------------------------------

async def function_name():  # Объявляет асинхронную функцию
    result = await some_operation()  # Ждет результат, не блокируя другие операции

await можно использовать только внутри async функций.

14.3 ПРИМЕРЫ В КОДЕ БОТА
------------------------

async def start_command(message: Message):
    await message.answer(help_text)  # Отправка сообщения

async def process_article_text(message: Message, state: FSMContext):
    await message.reply("Текст в обработке...")  # Не блокирует
    completion = client.chat.completions.create(...)  # Синхронный вызов OpenAI
    await state.update_data(...)  # Асинхронное обновление состояния

=====================================


15.1 ЛОКАЛЬНЫЙ ЗАПУСК
---------------------

1. Установить зависимости:
15. ЗАПУСК И РАЗВЕРТЫВАНИЕ

15.1 ЛОКАЛЬНЫЙ ЗАПУСК
---------------------

1. Установить зависимости:
   pip install -r requirements.txt

2. Создать .env файл:
   cp .env.example .env
   # Заполнить своими данными

3. Запустить бота:
   python bot.py

15.2 РАЗВЕРТЫВАНИЕ ЧЕРЕЗ DOCKER
-------------------------------

1. Собрать образ:
   docker build -t shipai-bot .

2. Запустить контейнер:
   docker-compose -f compose.dev.yaml up -d

15.3 ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ
-------------------------

Обязательные переменные:
- BOT_TOKEN: получить от @BotFather в Telegram
- API_KEY: получить на platform.openai.com
- CHANNEL_NAME: имя канала (например, @mychannel)

Необязательные переменные:
- MODEL: модель OpenAI (по умолчанию gpt-4.1-nano)
- DATABASE_FILE: файл БД (по умолчанию articles.db)


16. ВОЗМОЖНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ

16.1 ОШИБКИ OPENAI API
-----------------------

ПРОБЛЕМА: "Invalid API key"
РЕШЕНИЕ: Проверить правильность API_KEY в .env файле

ПРОБЛЕМА: "Rate limit exceeded"
РЕШЕНИЕ: Слишком много запросов к OpenAI, подождать или увеличить лимиты

ПРОБЛЕМА: "Model not found"
РЕШЕНИЕ: Проверить доступность модели в вашем OpenAI аккаунте

16.2 ОШИБКИ TELEGRAM BOT
-------------------------

ПРОБЛЕМА: "Unauthorized"
РЕШЕНИЕ: Проверить правильность BOT_TOKEN

ПРОБЛЕМА: "Chat not found"
РЕШЕНИЕ: Проверить правильность CHANNEL_NAME, убедиться что бот добавлен в канал как администратор

16.3 ОШИБКИ БАЗЫ ДАННЫХ
------------------------

ПРОБЛЕМА: "Database is locked"
РЕШЕНИЕ: Закрыть все соединения с БД, перезапустить бота

ПРОБЛЕМА: "No such table: articles"
РЕШЕНИЕ: Удалить файл БД, перезапустить бота (таблица создастся автоматически)

16.4 ОШИБКИ ПЛАНИРОВЩИКА
-------------------------

ПРОБЛЕМА: Статьи не публикуются автоматически
РЕШЕНИЕ: Проверить логи, убедиться что планировщик запущен

ПРОБЛЕМА: Дублирование публикаций
РЕШЕНИЕ: Перезапустить бота, проверить уникальность ID задач


17. РАСШИРЕНИЕ ФУНКЦИОНАЛЬНОСТИ

17.1 ДОБАВЛЕНИЕ НОВЫХ КОМАНД
-----------------------------

Для добавления новой команды:

1. Создать функцию-обработчик:
@article_router.message(Command("new_command"))
async def new_command_handler(message: Message):
    await message.reply("Ответ на новую команду")

2. Добавить описание в help_text

17.2 ИЗМЕНЕНИЕ РАСПИСАНИЯ ПУБЛИКАЦИЙ
------------------------------------

Для изменения времени публикаций:
1. Найти переменную slot_interval_minutes в функции schedule_posts()
2. Изменить значение (сейчас 132 минуты)
3. Изменить временные слоты в массиве time_slots

17.3 ДОБАВЛЕНИЕ НОВЫХ ТИПОВ КОНТЕНТА
------------------------------------

Для поддержки видео или документов:
1. Добавить новые состояния в ArticleSubmission
2. Создать обработчики с фильтрами F.content_type == "video"
3. Обновить функцию post_article_to_channel()

17.4 ИНТЕГРАЦИЯ С ДРУГИМИ AI СЕРВИСАМИ
--------------------------------------

Для замены OpenAI на другой сервис:
1. Изменить импорт в bot.py
2. Обновить функцию process_article_text()
3. Изменить формат запроса в соответствии с новым API


18. БЕЗОПАСНОСТЬ И ЛУЧШИЕ ПРАКТИКИ

18.1 БЕЗОПАСНОСТЬ
-----------------

- Никогда не коммитить .env файл в Git
- Использовать сильные API ключи
- Регулярно обновлять зависимости
- Ограничить права доступа к серверу

18.2 МОНИТОРИНГ
---------------

- Настроить логирование в файл
- Мониторить использование OpenAI API
- Отслеживать ошибки публикации
- Проверять размер базы данных

18.3 РЕЗЕРВНОЕ КОПИРОВАНИЕ
--------------------------

- Регулярно создавать бэкапы базы данных
- Сохранять изображения в облачном хранилище
- Делать бэкапы конфигурации


19. ЗАКЛЮЧЕНИЕ

Этот документ описывает полную архитектуру и принципы работы Telegram бота ShipAI. 

КЛЮЧЕВЫЕ КОМПОНЕНТЫ:
- Telegram Bot API (aiogram) для взаимодействия с пользователями
- OpenAI API для обработки текста
- SQLite для хранения данных
- APScheduler для автоматического планирования
- FSM для управления состояниями диалога

ОСНОВНОЙ ПОТОК РАБОТЫ:
1. Пользователь отправляет текст статьи
2. Бот обрабатывает текст через OpenAI
3. Добавляет статью в очередь публикаций
4. Планировщик автоматически назначает время
5. В назначенное время статья публикуется в канал

Бот спроектирован для автоматизации контент-маркетинга в Telegram каналах с использованием искусственного интеллекта для улучшения качества публикаций.

Для новичков в Python этот проект демонстрирует:
- Асинхронное программирование
- Работу с внешними API
- Управление состояниями приложения
- Планирование задач
- Работу с базами данных
- Обработку ошибок и логирование


